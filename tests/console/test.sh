#!/usr/bin/env zsh

# ./test.sh [OPTIONS] [FILENAMES...]
#
# Options:
#   -first       Stop on first failed test
#   -verifyIR    Verify the IR code generated by llvm. Also enables
#                the -first option.
#
# Run test(s) optionally using FILENAMES as input. Compare the output to the file
# with the same filename except with the ".result" extension.
#
# FILENAMES is the list of optional names of the logo script WITH the .lg extension.
#
# If FILENAMES is not specified then this will go through all the .lg files
# in the tests directory.

stop_on_first_failure=false
filenames=()
argc=0

# Parse options
while [[ $# -gt 0 ]]; do
    case $1 in
        -first)
            stop_on_first_failure=true
            shift
            ;;
        -verifyIR)
            verify_ir=true
            stop_on_first_failure=true
            shift
            ;;
        *)
            filenames+=("$1")
            ((argc++))
            shift
            ;;
    esac
done

# Change to the directory of the test script.
test_dir=$(dirname $0)
cd $test_dir

logo_binary=qlogo
logo_path="../../qlogo/$logo_binary"
failed_tests=()

exe_opts=""
if [ "$verify_ir" = true ]; then
    exe_opts="--verifyIR"
fi

run_test() {
    f="$1"
    if [[ $f == *.lg ]]
    then
        echo $f
        $logo_path $exe_opts < $f 2>&1 | diff "${f%.lg}.result" -
        if [ $? -eq 1 ]
        then
            failed_tests+=($f)
            if [ "$stop_on_first_failure" = true ]; then
                exit 1
            fi
        fi
    fi
}

if [ ! -f "$logo_path" ]
then
    echo "Error: could not find '$logo_binary' in parent directory."
    echo "There should be a logo executable or a symbolic link in my parent diectory."
    exit 0
fi

# Maximum number of parallel processes
max_jobs=8

if (( $argc > 0 ))
then
    for filename in ${filenames[*]}
    do
        run_test $filename
    done
else
    start_time=`date +%s`
    test_count=0
    
    # Create temporary file for collecting failed test names
    failed_test_file=$(mktemp /tmp/test_failed_XXXXXX)
    
    # Collect all .lg files first
    test_files=()
    for a in *.lg; do
        test_files+=("$a")
    done
    
    # Function to run a test in the background
    run_test_parallel() {
        f="$1"
        if [[ $f == *.lg ]]
        then
            echo $f
            # Run test in background
            (
                $logo_path $exe_opts < $f 2>&1 | diff "${f%.lg}.result" -
                exit_code=$?
                if [ $exit_code -eq 1 ]; then
                    # Append failed test name to shared file
                    echo "$f" >> "$failed_test_file"
                fi
            ) &
        fi
    }
    
    # Run tests in parallel, limiting to max_jobs concurrent processes
    job_pids=()
    for a in ${test_files[@]}; do
        # Wait for a job slot if we've reached the limit
        while (( ${#job_pids[@]} >= max_jobs )); do
            # Wait for any job to complete
            wait $job_pids[1]
            # Remove completed job from array
            job_pids=(${job_pids[2,-1]})
        done
        
        run_test_parallel $a
        # Store the PID of the background job (zsh stores it in $!)
        job_pids+=($!)
        ((++test_count))
    done
    
    # Wait for all remaining jobs to complete
    for pid in $job_pids; do
        wait $pid
    done
    
    # Read failed tests from the temporary file
    if [ -f "$failed_test_file" ] && [ -s "$failed_test_file" ]; then
        while IFS= read -r line; do
            failed_tests+=("$line")
        done < "$failed_test_file"
    fi
    rm -f "$failed_test_file"
    
    end_time=`date +%s`
    trt=$((end_time-start_time))

    if (( ${#failed_tests[@]} )); then
        echo
        echo "============================"
        echo "====" FAILED TESTS:
        echo "===="
        for f in ${failed_tests[@]}
        do
            echo "====" $f
            echo "===="
        done
        echo "============================"
    fi

    echo $test_count tests.
    echo Total Running time: ${trt} seconds
fi

if (( ${#failed_tests[@]} )); then
    exit 1
fi

exit 0
