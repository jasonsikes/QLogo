#!/bin/sh

# ./test.sh [OPTIONS] [FILENAMES...]
#
# Options:
#   -first       Stop on first failed test
#   -verifyIR    Verify the IR code generated by llvm. Also enables
#                the -first option.
#   -blacklisted Run tests from the blacklisted directory and report
#                passed tests instead of failed tests.
#
# Run test(s) optionally using FILENAMES as input. Compare the output to the file
# with the same filename except with the ".result" extension.
#
# FILENAMES is the list of optional names of the logo script WITH the .lg extension.
#
# If FILENAMES is not specified then this will go through all the .lg files
# in the tests directory.

stop_on_first_failure=false
blacklisted=false
verify_ir=false

# Parse options
while [ $# -gt 0 ]; do
    case $1 in
        -first)
            stop_on_first_failure=true
            shift
            ;;
        -verifyIR)
            verify_ir=true
            stop_on_first_failure=true
            shift
            ;;
        -blacklisted)
            blacklisted=true
            shift
            ;;
        *)
            break
            ;;
    esac
done
# Remaining arguments are filenames
saved_filenames="$*"
saved_argc=$#

# Change to the directory of the test script.
test_dir=$(dirname $0)
if [ "$blacklisted" = true ]; then
    cd $test_dir/blacklisted
else
    cd $test_dir/tests
fi

logo_binary=qlogo
logo_path="../../../qlogo/$logo_binary"
reported_tests=""

exe_opts=""
if [ "$verify_ir" = true ]; then
    exe_opts="--verifyIR"
fi

run_test() {
    f="$1"
    case $f in
        *.lg)
            echo $f
            $logo_path $exe_opts < $f 2>&1 | diff "${f%.lg}.result" -
            if [ $? -eq 1 ]
            then
                if [ "$blacklisted" != true ] && [ "$stop_on_first_failure" = true ]; then
                    exit 1
                fi
                reported_tests="$reported_tests$f
"
            else
                if [ "$blacklisted" = true ]; then
                    reported_tests="$reported_tests$f
"
                fi
            fi
            ;;
    esac
}

if [ ! -f "$logo_path" ]
then
    echo "Error: could not find '$logo_binary' in parent directory."
    echo "There should be a logo executable or a symbolic link in my parent diectory."
    exit 0
fi

# Maximum number of parallel processes
max_jobs=8

# Check if system has GNU date (supports %N for nanoseconds)
has_gnu_date() {
    # GNU date supports --version, BSD date doesn't
    if date --version >/dev/null 2>&1 && date --version 2>&1 | grep -q "GNU"; then
        return 0
    fi
    return 1
}

if [ $saved_argc -gt 0 ]
then
    for filename in $saved_filenames
    do
        run_test $filename
    done
else
    if has_gnu_date; then
        start_time=`date +%s%3N`
    fi
    test_count=0
    
    # Create temporary file for collecting test results
    reported_test_file=$(mktemp /tmp/test_reported_XXXXXX)
    
    # Collect all .lg files first
    test_files=""
    for a in *.lg; do
        test_files="$test_files $a"
    done
    
    # Function to run a test in the background
    run_test_parallel() {
        f="$1"
        case $f in
            *.lg)
                echo $f
                # Run test in background
                (
                    $logo_path $exe_opts < $f 2>&1 | diff "${f%.lg}.result" -
                    exit_code=$?
                    # Report: (blacklisted and passed) or (not blacklisted and failed)
                    if [ "$blacklisted" = true ] && [ $exit_code -eq 0 ]; then
                        echo "$f" >> "$reported_test_file"
                    elif [ "$blacklisted" != true ] && [ $exit_code -eq 1 ]; then
                        echo "$f" >> "$reported_test_file"
                    fi
                ) &
                ;;
        esac
    }
    
    # Run tests in parallel, limiting to max_jobs concurrent processes
    job_pids=""
    for a in $test_files; do
        # Wait for a job slot if we've reached the limit
        while true; do
            n=0
            for p in $job_pids; do
                n=$((n + 1))
            done
            [ $n -lt $max_jobs ] && break
            first_pid="${job_pids# }"
            first_pid="${first_pid%% *}"
            wait $first_pid 2>/dev/null
            job_pids="${job_pids#$first_pid}"
            job_pids="${job_pids# }"
        done
        
        run_test_parallel $a
        job_pids="$job_pids $!"
        test_count=$((test_count + 1))
    done
    
    # Wait for all remaining jobs to complete
    for pid in $job_pids; do
        wait $pid 2>/dev/null
    done
    
    # Read test results from the temporary file
    if [ -f "$reported_test_file" ] && [ -s "$reported_test_file" ]; then
        reported_tests=$(cat "$reported_test_file")
    fi
    rm -f "$reported_test_file"
    
    if has_gnu_date; then
        end_time=`date +%s%3N`
        trt=$((end_time-start_time))
    fi

    if [ -n "$reported_tests" ]; then
        echo
        echo "============================"
        if [ "$blacklisted" = true ]; then
            echo "====" PASSED TESTS:
        else
            echo "====" FAILED TESTS:
        fi
        echo "===="
        echo "$reported_tests" | while IFS= read -r f; do
            echo "====" $f
            echo "===="
        done
        echo "============================"
    fi

    echo $test_count tests.
    if has_gnu_date; then
        echo Total Running time: ${trt} milliseconds
    fi
fi

# Exit with error code if not blacklisted and there are reported tests
if [ "$blacklisted" != true ] && [ -n "$reported_tests" ]; then
    exit 1
fi
exit 0
